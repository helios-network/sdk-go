// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: helios/chronos/v1/types.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/Helios-Chain-Labs/sdk-go/chain/evm/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CronCallBackData struct {
	Data  []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Error []byte `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CronCallBackData) Reset()         { *m = CronCallBackData{} }
func (m *CronCallBackData) String() string { return proto.CompactTextString(m) }
func (*CronCallBackData) ProtoMessage()    {}
func (*CronCallBackData) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{0}
}
func (m *CronCallBackData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronCallBackData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronCallBackData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronCallBackData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronCallBackData.Merge(m, src)
}
func (m *CronCallBackData) XXX_Size() int {
	return m.Size()
}
func (m *CronCallBackData) XXX_DiscardUnknown() {
	xxx_messageInfo_CronCallBackData.DiscardUnknown(m)
}

var xxx_messageInfo_CronCallBackData proto.InternalMessageInfo

func (m *CronCallBackData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CronCallBackData) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

type CronTransactionResult struct {
	Tx          []byte `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	Result      []byte `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
	Nonce       uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	From        string `protobuf:"bytes,4,opt,name=from,proto3" json:"from,omitempty"`
	BlockNumber uint64 `protobuf:"varint,5,opt,name=block_number,json=blockNumber,proto3" json:"blockNumber"`
	BlockHash   string `protobuf:"bytes,6,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"`
	CronId      uint64 `protobuf:"varint,7,opt,name=cron_id,json=cronId,proto3" json:"cronId"`
	CronAddress string `protobuf:"bytes,8,opt,name=cron_address,json=cronAddress,proto3" json:"cronAddress"`
	TxHash      string `protobuf:"bytes,9,opt,name=tx_hash,json=txHash,proto3" json:"transactionHash"`
}

func (m *CronTransactionResult) Reset()         { *m = CronTransactionResult{} }
func (m *CronTransactionResult) String() string { return proto.CompactTextString(m) }
func (*CronTransactionResult) ProtoMessage()    {}
func (*CronTransactionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{1}
}
func (m *CronTransactionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronTransactionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronTransactionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronTransactionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronTransactionResult.Merge(m, src)
}
func (m *CronTransactionResult) XXX_Size() int {
	return m.Size()
}
func (m *CronTransactionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CronTransactionResult.DiscardUnknown(m)
}

var xxx_messageInfo_CronTransactionResult proto.InternalMessageInfo

func (m *CronTransactionResult) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *CronTransactionResult) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CronTransactionResult) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *CronTransactionResult) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *CronTransactionResult) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *CronTransactionResult) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *CronTransactionResult) GetCronId() uint64 {
	if m != nil {
		return m.CronId
	}
	return 0
}

func (m *CronTransactionResult) GetCronAddress() string {
	if m != nil {
		return m.CronAddress
	}
	return ""
}

func (m *CronTransactionResult) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

type CronTransactionReceiptRPC struct {
	// Consensus fields
	Status            string       `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	CumulativeGasUsed string       `protobuf:"bytes,2,opt,name=cumulative_gas_used,json=cumulativeGasUsed,proto3" json:"cumulativeGasUsed"`
	LogsBloom         string       `protobuf:"bytes,3,opt,name=logs_bloom,json=logsBloom,proto3" json:"logsBloom"`
	Logs              []*types.Log `protobuf:"bytes,4,rep,name=logs,proto3" json:"logs,omitempty"`
	// Implementation fields
	TransactionHash string `protobuf:"bytes,5,opt,name=transaction_hash,json=transactionHash,proto3" json:"transactionHash"`
	ContractAddress string `protobuf:"bytes,6,opt,name=contract_address,json=contractAddress,proto3" json:"contractAddress"`
	GasUsed         string `protobuf:"bytes,7,opt,name=gas_used,json=gasUsed,proto3" json:"gasUsed"`
	// Inclusion information
	BlockHash        string `protobuf:"bytes,8,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"`
	BlockNumber      string `protobuf:"bytes,9,opt,name=block_number,json=blockNumber,proto3" json:"blockNumber"`
	TransactionIndex string `protobuf:"bytes,10,opt,name=transaction_index,json=transactionIndex,proto3" json:"transactionIndex"`
	// Addresses
	From string `protobuf:"bytes,11,opt,name=from,proto3" json:"from,omitempty"`
	To   string `protobuf:"bytes,12,opt,name=to,proto3" json:"to,omitempty"`
	Type string `protobuf:"bytes,13,opt,name=type,proto3" json:"type,omitempty"`
	// execution result
	Result      string `protobuf:"bytes,14,opt,name=result,proto3" json:"result,omitempty"`
	Ret         string `protobuf:"bytes,15,opt,name=ret,proto3" json:"ret,omitempty"`
	VmError     string `protobuf:"bytes,16,opt,name=vm_error,json=vmError,proto3" json:"vmError"`
	CronId      uint64 `protobuf:"varint,17,opt,name=cron_id,json=cronId,proto3" json:"cronId"`
	CronAddress string `protobuf:"bytes,18,opt,name=cron_address,json=cronAddress,proto3" json:"cronAddress"`
}

func (m *CronTransactionReceiptRPC) Reset()         { *m = CronTransactionReceiptRPC{} }
func (m *CronTransactionReceiptRPC) String() string { return proto.CompactTextString(m) }
func (*CronTransactionReceiptRPC) ProtoMessage()    {}
func (*CronTransactionReceiptRPC) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{2}
}
func (m *CronTransactionReceiptRPC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronTransactionReceiptRPC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronTransactionReceiptRPC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronTransactionReceiptRPC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronTransactionReceiptRPC.Merge(m, src)
}
func (m *CronTransactionReceiptRPC) XXX_Size() int {
	return m.Size()
}
func (m *CronTransactionReceiptRPC) XXX_DiscardUnknown() {
	xxx_messageInfo_CronTransactionReceiptRPC.DiscardUnknown(m)
}

var xxx_messageInfo_CronTransactionReceiptRPC proto.InternalMessageInfo

func (m *CronTransactionReceiptRPC) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetCumulativeGasUsed() string {
	if m != nil {
		return m.CumulativeGasUsed
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetLogsBloom() string {
	if m != nil {
		return m.LogsBloom
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetLogs() []*types.Log {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *CronTransactionReceiptRPC) GetTransactionHash() string {
	if m != nil {
		return m.TransactionHash
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetGasUsed() string {
	if m != nil {
		return m.GasUsed
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetBlockNumber() string {
	if m != nil {
		return m.BlockNumber
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetTransactionIndex() string {
	if m != nil {
		return m.TransactionIndex
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetRet() string {
	if m != nil {
		return m.Ret
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetVmError() string {
	if m != nil {
		return m.VmError
	}
	return ""
}

func (m *CronTransactionReceiptRPC) GetCronId() uint64 {
	if m != nil {
		return m.CronId
	}
	return 0
}

func (m *CronTransactionReceiptRPC) GetCronAddress() string {
	if m != nil {
		return m.CronAddress
	}
	return ""
}

type CronTransactionRPC struct {
	BlockHash        string `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"`
	BlockNumber      string `protobuf:"bytes,2,opt,name=block_number,json=blockNumber,proto3" json:"blockNumber"`
	ChainId          string `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chainId"`
	From             string `protobuf:"bytes,4,opt,name=from,proto3" json:"from,omitempty"`
	Gas              string `protobuf:"bytes,5,opt,name=gas,proto3" json:"gas,omitempty"`
	GasPrice         string `protobuf:"bytes,6,opt,name=gas_price,json=gasPrice,proto3" json:"gasPrice"`
	Hash             string `protobuf:"bytes,7,opt,name=hash,proto3" json:"hash,omitempty"`
	Input            string `protobuf:"bytes,8,opt,name=input,proto3" json:"input,omitempty"`
	Nonce            string `protobuf:"bytes,9,opt,name=nonce,proto3" json:"nonce,omitempty"`
	R                string `protobuf:"bytes,10,opt,name=r,proto3" json:"r,omitempty"`
	S                string `protobuf:"bytes,11,opt,name=s,proto3" json:"s,omitempty"`
	To               string `protobuf:"bytes,12,opt,name=to,proto3" json:"to,omitempty"`
	TransactionIndex string `protobuf:"bytes,13,opt,name=transaction_index,json=transactionIndex,proto3" json:"transactionIndex"`
	Type             string `protobuf:"bytes,14,opt,name=type,proto3" json:"type,omitempty"`
	V                string `protobuf:"bytes,15,opt,name=v,proto3" json:"v,omitempty"`
	Value            string `protobuf:"bytes,16,opt,name=value,proto3" json:"value,omitempty"`
	CronId           uint64 `protobuf:"varint,17,opt,name=cron_id,json=cronId,proto3" json:"cronId"`
	CronAddress      string `protobuf:"bytes,18,opt,name=cron_address,json=cronAddress,proto3" json:"cronAddress"`
}

func (m *CronTransactionRPC) Reset()         { *m = CronTransactionRPC{} }
func (m *CronTransactionRPC) String() string { return proto.CompactTextString(m) }
func (*CronTransactionRPC) ProtoMessage()    {}
func (*CronTransactionRPC) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{3}
}
func (m *CronTransactionRPC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronTransactionRPC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronTransactionRPC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronTransactionRPC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronTransactionRPC.Merge(m, src)
}
func (m *CronTransactionRPC) XXX_Size() int {
	return m.Size()
}
func (m *CronTransactionRPC) XXX_DiscardUnknown() {
	xxx_messageInfo_CronTransactionRPC.DiscardUnknown(m)
}

var xxx_messageInfo_CronTransactionRPC proto.InternalMessageInfo

func (m *CronTransactionRPC) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *CronTransactionRPC) GetBlockNumber() string {
	if m != nil {
		return m.BlockNumber
	}
	return ""
}

func (m *CronTransactionRPC) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *CronTransactionRPC) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *CronTransactionRPC) GetGas() string {
	if m != nil {
		return m.Gas
	}
	return ""
}

func (m *CronTransactionRPC) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *CronTransactionRPC) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *CronTransactionRPC) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *CronTransactionRPC) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *CronTransactionRPC) GetR() string {
	if m != nil {
		return m.R
	}
	return ""
}

func (m *CronTransactionRPC) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *CronTransactionRPC) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CronTransactionRPC) GetTransactionIndex() string {
	if m != nil {
		return m.TransactionIndex
	}
	return ""
}

func (m *CronTransactionRPC) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CronTransactionRPC) GetV() string {
	if m != nil {
		return m.V
	}
	return ""
}

func (m *CronTransactionRPC) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *CronTransactionRPC) GetCronId() uint64 {
	if m != nil {
		return m.CronId
	}
	return 0
}

func (m *CronTransactionRPC) GetCronAddress() string {
	if m != nil {
		return m.CronAddress
	}
	return ""
}

type CronStatistics struct {
	CronCount              uint64 `protobuf:"varint,1,opt,name=cron_count,json=cronCount,proto3" json:"cronCount"`
	QueueCount             uint64 `protobuf:"varint,2,opt,name=queue_count,json=queueCount,proto3" json:"queueCount"`
	ArchivedCrons          uint64 `protobuf:"varint,3,opt,name=archived_crons,json=archivedCrons,proto3" json:"archivedCrons"`
	RefundedLastBlockCount uint64 `protobuf:"varint,4,opt,name=refunded_last_block_count,json=refundedLastBlockCount,proto3" json:"refundedLastBlockCount"`
	ExecutedLastBlockCount uint64 `protobuf:"varint,5,opt,name=executed_last_block_count,json=executedLastBlockCount,proto3" json:"executedLastBlockCount"`
}

func (m *CronStatistics) Reset()         { *m = CronStatistics{} }
func (m *CronStatistics) String() string { return proto.CompactTextString(m) }
func (*CronStatistics) ProtoMessage()    {}
func (*CronStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{4}
}
func (m *CronStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronStatistics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronStatistics.Merge(m, src)
}
func (m *CronStatistics) XXX_Size() int {
	return m.Size()
}
func (m *CronStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_CronStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_CronStatistics proto.InternalMessageInfo

func (m *CronStatistics) GetCronCount() uint64 {
	if m != nil {
		return m.CronCount
	}
	return 0
}

func (m *CronStatistics) GetQueueCount() uint64 {
	if m != nil {
		return m.QueueCount
	}
	return 0
}

func (m *CronStatistics) GetArchivedCrons() uint64 {
	if m != nil {
		return m.ArchivedCrons
	}
	return 0
}

func (m *CronStatistics) GetRefundedLastBlockCount() uint64 {
	if m != nil {
		return m.RefundedLastBlockCount
	}
	return 0
}

func (m *CronStatistics) GetExecutedLastBlockCount() uint64 {
	if m != nil {
		return m.ExecutedLastBlockCount
	}
	return 0
}

type IdAndTimestamp struct {
	Id        uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *IdAndTimestamp) Reset()         { *m = IdAndTimestamp{} }
func (m *IdAndTimestamp) String() string { return proto.CompactTextString(m) }
func (*IdAndTimestamp) ProtoMessage()    {}
func (*IdAndTimestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{5}
}
func (m *IdAndTimestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdAndTimestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdAndTimestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdAndTimestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdAndTimestamp.Merge(m, src)
}
func (m *IdAndTimestamp) XXX_Size() int {
	return m.Size()
}
func (m *IdAndTimestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_IdAndTimestamp.DiscardUnknown(m)
}

var xxx_messageInfo_IdAndTimestamp proto.InternalMessageInfo

func (m *IdAndTimestamp) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IdAndTimestamp) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type IDSet struct {
	Ids []*IdAndTimestamp `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (m *IDSet) Reset()         { *m = IDSet{} }
func (m *IDSet) String() string { return proto.CompactTextString(m) }
func (*IDSet) ProtoMessage()    {}
func (*IDSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{6}
}
func (m *IDSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDSet.Merge(m, src)
}
func (m *IDSet) XXX_Size() int {
	return m.Size()
}
func (m *IDSet) XXX_DiscardUnknown() {
	xxx_messageInfo_IDSet.DiscardUnknown(m)
}

var xxx_messageInfo_IDSet proto.InternalMessageInfo

func (m *IDSet) GetIds() []*IdAndTimestamp {
	if m != nil {
		return m.Ids
	}
	return nil
}

type BatchFeesWithIds struct {
	TotalFees       cosmossdk_io_math.Int   `protobuf:"bytes,1,opt,name=total_fees,json=totalFees,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees"`
	Ids             []uint64                `protobuf:"varint,2,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	Fees            []cosmossdk_io_math.Int `protobuf:"bytes,3,rep,name=fees,proto3,customtype=cosmossdk.io/math.Int" json:"fees"`
	ExpiredIds      []uint64                `protobuf:"varint,4,rep,packed,name=expired_ids,json=expiredIds,proto3" json:"expired_ids,omitempty"`
	TotalQueueCount uint64                  `protobuf:"varint,5,opt,name=total_queue_count,json=totalQueueCount,proto3" json:"total_queue_count,omitempty"`
}

func (m *BatchFeesWithIds) Reset()         { *m = BatchFeesWithIds{} }
func (m *BatchFeesWithIds) String() string { return proto.CompactTextString(m) }
func (*BatchFeesWithIds) ProtoMessage()    {}
func (*BatchFeesWithIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd54e5dd8b5f8dac, []int{7}
}
func (m *BatchFeesWithIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchFeesWithIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchFeesWithIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchFeesWithIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchFeesWithIds.Merge(m, src)
}
func (m *BatchFeesWithIds) XXX_Size() int {
	return m.Size()
}
func (m *BatchFeesWithIds) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchFeesWithIds.DiscardUnknown(m)
}

var xxx_messageInfo_BatchFeesWithIds proto.InternalMessageInfo

func (m *BatchFeesWithIds) GetIds() []uint64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *BatchFeesWithIds) GetExpiredIds() []uint64 {
	if m != nil {
		return m.ExpiredIds
	}
	return nil
}

func (m *BatchFeesWithIds) GetTotalQueueCount() uint64 {
	if m != nil {
		return m.TotalQueueCount
	}
	return 0
}

func init() {
	proto.RegisterType((*CronCallBackData)(nil), "helios.chronos.v1.CronCallBackData")
	proto.RegisterType((*CronTransactionResult)(nil), "helios.chronos.v1.CronTransactionResult")
	proto.RegisterType((*CronTransactionReceiptRPC)(nil), "helios.chronos.v1.CronTransactionReceiptRPC")
	proto.RegisterType((*CronTransactionRPC)(nil), "helios.chronos.v1.CronTransactionRPC")
	proto.RegisterType((*CronStatistics)(nil), "helios.chronos.v1.CronStatistics")
	proto.RegisterType((*IdAndTimestamp)(nil), "helios.chronos.v1.IdAndTimestamp")
	proto.RegisterType((*IDSet)(nil), "helios.chronos.v1.IDSet")
	proto.RegisterType((*BatchFeesWithIds)(nil), "helios.chronos.v1.BatchFeesWithIds")
}

func init() { proto.RegisterFile("helios/chronos/v1/types.proto", fileDescriptor_dd54e5dd8b5f8dac) }

var fileDescriptor_dd54e5dd8b5f8dac = []byte{
	// 1125 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xc1, 0x6e, 0xdb, 0x46,
	0x13, 0x36, 0x25, 0x59, 0xb2, 0x56, 0xb2, 0x2c, 0x6d, 0xe2, 0x80, 0x31, 0xfe, 0x88, 0xfa, 0x55,
	0x20, 0x50, 0x8a, 0x54, 0x82, 0x93, 0x4b, 0x0f, 0x46, 0x00, 0xcb, 0x49, 0x5b, 0x01, 0x41, 0xe1,
	0x6e, 0x12, 0x14, 0xe8, 0x45, 0x58, 0x93, 0x6b, 0x89, 0xb0, 0xc8, 0x55, 0x77, 0x97, 0x84, 0xfa,
	0x14, 0xed, 0x9b, 0xf4, 0x35, 0x72, 0x0c, 0x7a, 0x69, 0xd1, 0x03, 0x51, 0xd8, 0x37, 0x3d, 0x45,
	0x31, 0xbb, 0xa4, 0xa8, 0xc8, 0x36, 0x9c, 0x1c, 0x7a, 0xe2, 0xcc, 0x37, 0xb3, 0x1f, 0x87, 0xb3,
	0xdf, 0x2c, 0x17, 0x3d, 0x9a, 0xb2, 0x99, 0xcf, 0xe5, 0xc0, 0x9d, 0x0a, 0x1e, 0x72, 0x39, 0x88,
	0x0f, 0x07, 0xea, 0x97, 0x39, 0x93, 0xfd, 0xb9, 0xe0, 0x8a, 0xe3, 0x96, 0x09, 0xf7, 0xd3, 0x70,
	0x3f, 0x3e, 0x3c, 0xb8, 0x3f, 0xe1, 0x13, 0xae, 0xa3, 0x03, 0xb0, 0x4c, 0xe2, 0xc1, 0x01, 0x53,
	0x53, 0x26, 0x02, 0x3f, 0x54, 0x03, 0x16, 0x07, 0x40, 0xc3, 0xe2, 0xc0, 0xc4, 0xba, 0x47, 0xa8,
	0x79, 0x22, 0x78, 0x78, 0x42, 0x67, 0xb3, 0x21, 0x75, 0x2f, 0x5e, 0x52, 0x45, 0x31, 0x46, 0x25,
	0x8f, 0x2a, 0x6a, 0x5b, 0x1d, 0xab, 0x57, 0x27, 0xda, 0xc6, 0xf7, 0xd1, 0x36, 0x13, 0x82, 0x0b,
	0xbb, 0xa0, 0x41, 0xe3, 0x74, 0xff, 0x28, 0xa0, 0x7d, 0x58, 0xfe, 0x56, 0xd0, 0x50, 0x52, 0x57,
	0xf9, 0x3c, 0x24, 0x4c, 0x46, 0x33, 0x85, 0x1b, 0xa8, 0xa0, 0x16, 0x29, 0x43, 0x41, 0x2d, 0xf0,
	0x03, 0x54, 0x16, 0x3a, 0x92, 0x12, 0xa4, 0x1e, 0xf0, 0x86, 0x3c, 0x74, 0x99, 0x5d, 0xec, 0x58,
	0xbd, 0x12, 0x31, 0x0e, 0x54, 0x70, 0x2e, 0x78, 0x60, 0x97, 0x3a, 0x56, 0xaf, 0x4a, 0xb4, 0x8d,
	0x9f, 0xa1, 0xfa, 0xd9, 0x8c, 0xbb, 0x17, 0xe3, 0x30, 0x0a, 0xce, 0x98, 0xb0, 0xb7, 0x61, 0xc1,
	0x70, 0x6f, 0x99, 0x38, 0x35, 0x8d, 0x7f, 0xaf, 0x61, 0xb2, 0xee, 0xe0, 0xa7, 0x08, 0x99, 0x35,
	0x53, 0x2a, 0xa7, 0x76, 0x19, 0xd8, 0x86, 0xbb, 0xcb, 0xc4, 0xa9, 0x6a, 0xf4, 0x3b, 0x2a, 0xa7,
	0x24, 0x37, 0xf1, 0x17, 0xa8, 0xe2, 0x0a, 0x1e, 0x8e, 0x7d, 0xcf, 0xae, 0x68, 0x72, 0xb4, 0x4c,
	0x9c, 0x32, 0x40, 0x23, 0x8f, 0xa4, 0x4f, 0x28, 0x43, 0x27, 0x51, 0xcf, 0x13, 0x4c, 0x4a, 0x7b,
	0x47, 0x93, 0xea, 0x32, 0x00, 0x3f, 0x36, 0x30, 0x59, 0x77, 0xf0, 0x53, 0x54, 0x51, 0x0b, 0x53,
	0x43, 0x55, 0xa7, 0xdf, 0x5b, 0x26, 0xce, 0x9e, 0xca, 0x9b, 0xa6, 0x2b, 0x29, 0xab, 0x05, 0x3c,
	0xbb, 0xbf, 0x96, 0xd1, 0xc3, 0x6b, 0x4d, 0x75, 0x99, 0x3f, 0x57, 0xe4, 0xf4, 0x04, 0x77, 0x51,
	0x59, 0x2a, 0xaa, 0x22, 0xa9, 0x9b, 0x5b, 0x35, 0x35, 0x1a, 0x84, 0xa4, 0x4f, 0xfc, 0x0a, 0xdd,
	0x73, 0xa3, 0x20, 0x9a, 0x51, 0xe5, 0xc7, 0x6c, 0x3c, 0xa1, 0x72, 0x1c, 0x49, 0xe6, 0xe9, 0xce,
	0x57, 0x87, 0xfb, 0xcb, 0xc4, 0x69, 0xe5, 0xe1, 0x6f, 0xa9, 0x7c, 0x27, 0x99, 0x47, 0xae, 0x43,
	0xd0, 0xbd, 0x19, 0x9f, 0xc8, 0xf1, 0xd9, 0x8c, 0xf3, 0x40, 0x6f, 0x50, 0xda, 0x3d, 0x40, 0x87,
	0x00, 0x92, 0xdc, 0xc4, 0x4f, 0x50, 0x09, 0x1c, 0xbb, 0xd4, 0x29, 0xf6, 0x6a, 0xcf, 0xf6, 0xfb,
	0x2b, 0xd1, 0xf5, 0x41, 0x6d, 0xf1, 0x61, 0xff, 0x35, 0x9f, 0x10, 0x9d, 0x82, 0x5f, 0xa0, 0xe6,
	0xda, 0xc7, 0x9b, 0xc6, 0x6c, 0xdf, 0xde, 0x98, 0x4d, 0x00, 0xd6, 0xbb, 0x3c, 0x54, 0x82, 0xba,
	0x6a, 0xb5, 0x0f, 0xe5, 0x7c, 0x7d, 0x16, 0xcb, 0xf6, 0x62, 0x13, 0xc0, 0x8f, 0xd1, 0xce, 0xaa,
	0x29, 0x15, 0xbd, 0xae, 0xb6, 0x4c, 0x9c, 0xca, 0x24, 0x6d, 0x45, 0x66, 0x6c, 0xc8, 0x67, 0xe7,
	0x0e, 0xf9, 0x6c, 0x0a, 0xb4, 0x9a, 0x2b, 0xe3, 0x56, 0x81, 0x1e, 0xa3, 0xd6, 0x7a, 0x27, 0xfc,
	0xd0, 0x63, 0x0b, 0x1b, 0xe9, 0x85, 0xf7, 0x97, 0x89, 0xb3, 0xde, 0xa6, 0x11, 0xc4, 0xc8, 0x35,
	0x64, 0x35, 0x2b, 0xb5, 0xb5, 0x59, 0x81, 0xe9, 0xe3, 0x76, 0x5d, 0x23, 0x05, 0xc5, 0x21, 0x07,
	0x4e, 0x0e, 0x7b, 0xd7, 0xe4, 0x80, 0xbd, 0x36, 0x91, 0x0d, 0x8d, 0x66, 0x13, 0xd9, 0x44, 0x45,
	0xc1, 0x94, 0xbd, 0xa7, 0x41, 0x30, 0xa1, 0x5d, 0x71, 0x30, 0x36, 0xe3, 0xdf, 0xcc, 0xdb, 0x15,
	0x07, 0xaf, 0x00, 0x22, 0x99, 0xb1, 0x3e, 0x3f, 0xad, 0x4f, 0x9e, 0x1f, 0x7c, 0xf7, 0xfc, 0x74,
	0x7f, 0x2f, 0x21, 0xbc, 0x39, 0x11, 0xa7, 0x27, 0x1b, 0xdb, 0x63, 0x7d, 0xe6, 0xf6, 0x14, 0x3e,
	0x61, 0x7b, 0x1e, 0xa3, 0x1d, 0x77, 0x4a, 0x7d, 0xfd, 0x49, 0xc5, 0xfc, 0xcb, 0x35, 0x36, 0xf2,
	0x48, 0x66, 0xdc, 0x78, 0x5e, 0x35, 0x51, 0x71, 0x42, 0xa5, 0xd1, 0x35, 0x01, 0x13, 0x3f, 0x41,
	0x55, 0x90, 0xdd, 0x5c, 0xf8, 0x2e, 0x4b, 0xf5, 0x5a, 0x5f, 0x26, 0x0e, 0x68, 0xf1, 0x14, 0x30,
	0xb2, 0xb2, 0x80, 0x50, 0x7f, 0x54, 0xc5, 0x10, 0x82, 0x0d, 0x47, 0xa5, 0x1f, 0xce, 0x23, 0x65,
	0x84, 0x48, 0x8c, 0x93, 0x1f, 0xa0, 0x55, 0x83, 0x9a, 0x03, 0xb4, 0x8e, 0x2c, 0x61, 0x74, 0x44,
	0x2c, 0x01, 0x9e, 0x4c, 0xf5, 0x61, 0xc9, 0x6b, 0xe2, 0xb8, 0x51, 0x83, 0xbb, 0x9f, 0xab, 0x41,
	0xad, 0xaf, 0xc6, 0x9a, 0xbe, 0xea, 0xc8, 0x8a, 0x53, 0x15, 0x59, 0x31, 0x94, 0x19, 0xd3, 0x59,
	0xc4, 0x8c, 0x80, 0x88, 0x71, 0xfe, 0x3b, 0xc5, 0xfc, 0x59, 0x40, 0x0d, 0x50, 0xcc, 0x1b, 0x45,
	0x95, 0x2f, 0x95, 0xef, 0xc2, 0x21, 0x8c, 0x34, 0x8d, 0xcb, 0xa3, 0x50, 0x69, 0xb5, 0x94, 0x8c,
	0x5a, 0x00, 0x3d, 0x01, 0x90, 0xe4, 0x26, 0x1e, 0xa0, 0xda, 0xcf, 0x11, 0x8b, 0x58, 0x9a, 0x5e,
	0xd0, 0xe9, 0x8d, 0x65, 0xe2, 0x20, 0x0d, 0x9b, 0xfc, 0x35, 0x1b, 0x7f, 0x8d, 0x1a, 0x54, 0xb8,
	0x53, 0x3f, 0x66, 0xde, 0x18, 0x68, 0xa4, 0xf9, 0xa3, 0x0d, 0x5b, 0xcb, 0xc4, 0xd9, 0xcd, 0x22,
	0x50, 0x92, 0x24, 0x1f, 0xbb, 0xf8, 0x1d, 0x7a, 0x28, 0xd8, 0x79, 0x14, 0x7a, 0xcc, 0x1b, 0xcf,
	0xa8, 0x54, 0x63, 0x23, 0x53, 0xf3, 0xe2, 0x92, 0x26, 0x39, 0x58, 0x26, 0xce, 0x83, 0x2c, 0xe9,
	0x35, 0x95, 0x6a, 0x08, 0x29, 0xa6, 0x88, 0x5b, 0x70, 0xa0, 0x65, 0x0b, 0xe6, 0x46, 0xea, 0x26,
	0xda, 0xed, 0x9c, 0x36, 0x4b, 0xda, 0xa4, 0xbd, 0x19, 0xef, 0xbe, 0x40, 0x8d, 0x91, 0x77, 0x1c,
	0x7a, 0x6f, 0xfd, 0x80, 0x49, 0x45, 0x83, 0x39, 0xe8, 0xc9, 0xf7, 0x4c, 0x43, 0x49, 0xc1, 0xf7,
	0xf0, 0xff, 0x50, 0x55, 0x65, 0x41, 0xd3, 0x38, 0x92, 0x03, 0xdd, 0x23, 0xb4, 0x3d, 0x7a, 0xf9,
	0x86, 0x29, 0xfc, 0x1c, 0x15, 0x7d, 0x0f, 0xfe, 0x62, 0xf0, 0xbb, 0xf8, 0x7f, 0xff, 0xda, 0x65,
	0xa6, 0xff, 0xf1, 0x6b, 0x08, 0x64, 0x77, 0x2f, 0x2d, 0xd4, 0x1c, 0x52, 0xe5, 0x4e, 0xbf, 0x61,
	0x4c, 0xfe, 0xe8, 0xab, 0xe9, 0xc8, 0x93, 0xf8, 0x08, 0x21, 0xc5, 0x15, 0x9d, 0x8d, 0xcf, 0x19,
	0xcb, 0x7e, 0x8b, 0x8f, 0xde, 0x27, 0xce, 0xd6, 0xdf, 0x89, 0xb3, 0xef, 0x72, 0x19, 0x70, 0x29,
	0xbd, 0x8b, 0xbe, 0xcf, 0x07, 0x01, 0x55, 0xd3, 0xfe, 0x08, 0x76, 0x5a, 0x2f, 0x00, 0x12, 0x98,
	0x53, 0xa8, 0xa3, 0xd0, 0x29, 0xf6, 0x4a, 0xfa, 0x25, 0xf8, 0x10, 0x95, 0x34, 0x53, 0xb1, 0x53,
	0xbc, 0x9b, 0x49, 0xa7, 0x62, 0x07, 0xd5, 0xd8, 0x62, 0xee, 0x0b, 0xe6, 0x8d, 0x81, 0xac, 0xa4,
	0xc9, 0x50, 0x0a, 0x41, 0x8d, 0x5f, 0xa2, 0x96, 0xa9, 0x71, 0x5d, 0x55, 0x7a, 0x17, 0xc8, 0x9e,
	0x0e, 0xfc, 0xb0, 0x92, 0xd2, 0x70, 0xf8, 0xfe, 0xb2, 0x6d, 0x7d, 0xb8, 0x6c, 0x5b, 0xff, 0x5c,
	0xb6, 0xad, 0xdf, 0xae, 0xda, 0x5b, 0x1f, 0xae, 0xda, 0x5b, 0x7f, 0x5d, 0xb5, 0xb7, 0x7e, 0xea,
	0x99, 0x2e, 0x7d, 0xe5, 0x72, 0xc1, 0x06, 0x99, 0x0d, 0x67, 0xd0, 0x60, 0xb1, 0xba, 0x25, 0xea,
	0x2b, 0xe2, 0x59, 0x59, 0x5f, 0xef, 0x9e, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xde, 0x70, 0xbf,
	0x27, 0x44, 0x0a, 0x00, 0x00,
}

func (m *CronCallBackData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronCallBackData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronCallBackData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronTransactionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronTransactionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronTransactionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CronAddress) > 0 {
		i -= len(m.CronAddress)
		copy(dAtA[i:], m.CronAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CronAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.CronId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CronId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.BlockNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nonce != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronTransactionReceiptRPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronTransactionReceiptRPC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronTransactionReceiptRPC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CronAddress) > 0 {
		i -= len(m.CronAddress)
		copy(dAtA[i:], m.CronAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CronAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.CronId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CronId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.VmError) > 0 {
		i -= len(m.VmError)
		copy(dAtA[i:], m.VmError)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VmError)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Ret) > 0 {
		i -= len(m.Ret)
		copy(dAtA[i:], m.Ret)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ret)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TransactionIndex) > 0 {
		i -= len(m.TransactionIndex)
		copy(dAtA[i:], m.TransactionIndex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TransactionIndex)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.BlockNumber) > 0 {
		i -= len(m.BlockNumber)
		copy(dAtA[i:], m.BlockNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockNumber)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GasUsed) > 0 {
		i -= len(m.GasUsed)
		copy(dAtA[i:], m.GasUsed)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GasUsed)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LogsBloom) > 0 {
		i -= len(m.LogsBloom)
		copy(dAtA[i:], m.LogsBloom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LogsBloom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CumulativeGasUsed) > 0 {
		i -= len(m.CumulativeGasUsed)
		copy(dAtA[i:], m.CumulativeGasUsed)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CumulativeGasUsed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronTransactionRPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronTransactionRPC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronTransactionRPC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CronAddress) > 0 {
		i -= len(m.CronAddress)
		copy(dAtA[i:], m.CronAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CronAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.CronId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CronId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.V) > 0 {
		i -= len(m.V)
		copy(dAtA[i:], m.V)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.V)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.TransactionIndex) > 0 {
		i -= len(m.TransactionIndex)
		copy(dAtA[i:], m.TransactionIndex)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TransactionIndex)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.R) > 0 {
		i -= len(m.R)
		copy(dAtA[i:], m.R)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.R)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Input) > 0 {
		i -= len(m.Input)
		copy(dAtA[i:], m.Input)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Input)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Gas) > 0 {
		i -= len(m.Gas)
		copy(dAtA[i:], m.Gas)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Gas)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockNumber) > 0 {
		i -= len(m.BlockNumber)
		copy(dAtA[i:], m.BlockNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockNumber)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutedLastBlockCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExecutedLastBlockCount))
		i--
		dAtA[i] = 0x28
	}
	if m.RefundedLastBlockCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RefundedLastBlockCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ArchivedCrons != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ArchivedCrons))
		i--
		dAtA[i] = 0x18
	}
	if m.QueueCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.QueueCount))
		i--
		dAtA[i] = 0x10
	}
	if m.CronCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CronCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IdAndTimestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdAndTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdAndTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IDSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchFeesWithIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchFeesWithIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchFeesWithIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalQueueCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalQueueCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExpiredIds) > 0 {
		dAtA2 := make([]byte, len(m.ExpiredIds)*10)
		var j1 int
		for _, num := range m.ExpiredIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fees) > 0 {
		for iNdEx := len(m.Fees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.Fees[iNdEx].Size()
				i -= size
				if _, err := m.Fees[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ids) > 0 {
		dAtA4 := make([]byte, len(m.Ids)*10)
		var j3 int
		for _, num := range m.Ids {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.TotalFees.Size()
		i -= size
		if _, err := m.TotalFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CronCallBackData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CronTransactionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovTypes(uint64(m.Nonce))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovTypes(uint64(m.BlockNumber))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CronId != 0 {
		n += 1 + sovTypes(uint64(m.CronId))
	}
	l = len(m.CronAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CronTransactionReceiptRPC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CumulativeGasUsed)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LogsBloom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GasUsed)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BlockNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TransactionIndex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ret)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VmError)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CronId != 0 {
		n += 2 + sovTypes(uint64(m.CronId))
	}
	l = len(m.CronAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CronTransactionRPC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BlockNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Gas)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TransactionIndex)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.V)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CronId != 0 {
		n += 2 + sovTypes(uint64(m.CronId))
	}
	l = len(m.CronAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CronStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CronCount != 0 {
		n += 1 + sovTypes(uint64(m.CronCount))
	}
	if m.QueueCount != 0 {
		n += 1 + sovTypes(uint64(m.QueueCount))
	}
	if m.ArchivedCrons != 0 {
		n += 1 + sovTypes(uint64(m.ArchivedCrons))
	}
	if m.RefundedLastBlockCount != 0 {
		n += 1 + sovTypes(uint64(m.RefundedLastBlockCount))
	}
	if m.ExecutedLastBlockCount != 0 {
		n += 1 + sovTypes(uint64(m.ExecutedLastBlockCount))
	}
	return n
}

func (m *IdAndTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTypes(uint64(m.Timestamp))
	}
	return n
}

func (m *IDSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BatchFeesWithIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalFees.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Fees) > 0 {
		for _, e := range m.Fees {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExpiredIds) > 0 {
		l = 0
		for _, e := range m.ExpiredIds {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.TotalQueueCount != 0 {
		n += 1 + sovTypes(uint64(m.TotalQueueCount))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CronCallBackData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronCallBackData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronCallBackData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronTransactionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronTransactionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronTransactionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronId", wireType)
			}
			m.CronId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CronId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronTransactionReceiptRPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronTransactionReceiptRPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronTransactionReceiptRPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeGasUsed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeGasUsed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsBloom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &types.Log{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasUsed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronId", wireType)
			}
			m.CronId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CronId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronTransactionRPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronTransactionRPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronTransactionRPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronId", wireType)
			}
			m.CronId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CronId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronCount", wireType)
			}
			m.CronCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CronCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueCount", wireType)
			}
			m.QueueCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedCrons", wireType)
			}
			m.ArchivedCrons = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedCrons |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundedLastBlockCount", wireType)
			}
			m.RefundedLastBlockCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundedLastBlockCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutedLastBlockCount", wireType)
			}
			m.ExecutedLastBlockCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutedLastBlockCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdAndTimestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdAndTimestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdAndTimestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &IdAndTimestamp{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchFeesWithIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchFeesWithIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchFeesWithIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.Int
			m.Fees = append(m.Fees, v)
			if err := m.Fees[len(m.Fees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExpiredIds = append(m.ExpiredIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExpiredIds) == 0 {
					m.ExpiredIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExpiredIds = append(m.ExpiredIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredIds", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQueueCount", wireType)
			}
			m.TotalQueueCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalQueueCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
